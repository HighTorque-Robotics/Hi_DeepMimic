<!-- Generated by SpecStory -->

# 动作结束后身体混乱的原因 (2025-07-18 10:30Z)

_**User**_

debug为什么动作结束之后，整个身体就拳缩乱飞了？

---

_**Assistant**_

<think><details><summary>Thought Process</summary>用户询问为什么动作结束后，整个身体就蜷缩乱飞了。我需要分析这个sim2sim的代码，找出可能导致这个问题的原因。

让我仔细看看代码：

1. 首先，这是一个仿真到仿真的代码，使用MuJoCo进行物理仿真
2. 使用了一个motion_loader来加载运动数据
3. 使用一个训练好的策略网络来生成动作
4. 用PD控制器来控制关节

让我分析可能的问题：

1. `phase`的计算：
```python
phase = (count_lowlevel * Sim2simCfg.sim_config.dt) / motion_loader.record_time 
phase %= 0.99
```

这里phase被限制在0.99以下，当动作结束时（phase接近1.0），phase会突然跳回到0，这可能导致目标位置的突然变化。

2. 目标位置的计算：
```python
target_q_delta_lab = action_lab * 0.25
dof_pos_ref = motion_loader.get_dof_pos_batch(phase=torch.Tensor([phase]))[0].cpu().numpy()
target_q_mujoco[0][i] = dof_pos_ref[i] + target_q_delta_mjc[0][i] 
```

当phase突然从0.99跳回到0时，`dof_pos_ref`会从动作结束的姿态突然跳回到动作开始的姿态，这会导致目标位置的剧烈变化。
</details></think>

---

我来分析一下这个代码，找出动作结束后身体蜷缩乱飞的原因。让我先查看相关的motion_loader代码：

---

<details>
            <summary>Searched codebase "motion_loader" • **5** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |

</details>

---

<think><details><summary>Thought Process</summary>现在我看到有几个motion_loader相关的文件。从import语句来看，这个sim2sim.py文件是从scripts目录下导入motion_loader的：

```python
from motion_loader import MotionLoader
```

所以我应该查看scripts目录下的motion_loader.py文件。</details></think>

---

Read file: mimic_real/scripts/motion_loader.py

---

<think><details><summary>Thought Process</summary>看到motion_loader的代码，我现在需要看看get_frame_ids_batch和相关的batch处理方法，因为问题很可能出现在phase处理上。让我继续看这个文件的其余部分。</details></think>

---

Read file: mimic_real/scripts/motion_loader.py

---

<think><details><summary>Thought Process</summary>现在我明白问题的根源了！让我来分析一下：

1. 在sim2sim代码中，phase的计算是：
```python
phase = (count_lowlevel * Sim2simCfg.sim_config.dt) / motion_loader.record_time 
phase %= 0.99
```

2. 在motion_loader中，frame_ids的计算是：
```python
self.frame_ids = (phase * (self.frame_num - 1)).to(torch.long)
```

问题出现在：

1. **相位跳跃**：当phase接近1.0时，会突然跳回到0（因为`phase %= 0.99`），这会导致动作突然从结束姿态跳回到开始姿态。

2. **帧索引计算**：`phase * (self.frame_num - 1)` 意味着当phase=0.99时，frame_ids几乎是最后一帧，但当phase跳回0时，frame_ids又回到第一帧。

3. **目标位置突变**：`dof_pos_ref = motion_loader.get_dof_pos_batch(phase=torch.Tensor([phase]))[0].cpu().numpy()` 会随着phase的跳跃而发生剧烈变化。

4. **PD控制器响应**：当目标位置突然从动作结束的姿态跳回到开始姿态时，PD控制器会产生很大的控制力矩，导致机器人"乱飞"。

解决方案有几种：

1. 平滑地处理相位边界
2. 在动作结束时保持最后的姿态
</details></think>

---

通过分析代码，我找到了导致身体蜷缩乱飞的根本原因。问题出现在**相位(phase)的处理**上：

## 问题分析

1. **相位跳跃问题**：
```python
phase = (count_lowlevel * Sim2simCfg.sim_config.dt) / motion_loader.record_time 
phase %= 0.99
```
当动作接近结束时（phase接近0.99），会突然跳回到0，导致目标姿态从动作结束突然跳回到动作开始。

2. **目标位置突变**：
```python
dof_pos_ref = motion_loader.get_dof_pos_batch(phase=torch.Tensor([phase]))[0].cpu().numpy()
```
由于phase的突然跳跃，参考关节位置会发生剧烈变化。

3. **PD控制器过度响应**：当目标位置突然变化时，PD控制器会产生很大的力矩来纠正偏差，导致机器人失控。

## 解决方案

我来修复这个问题，添加平滑的相位处理：

---

```diff
      hist_obs = np.zeros([1, env.num_his_obs])
      last_tau = np.zeros((env.num_actions), dtype=np.double)
- 
+     
+     # 添加平滑处理变量
+     last_target_q_mujoco = np.zeros((1, env.num_actions), dtype=np.double)
+     motion_finished = False
+     hold_final_pose = False
+ 
      count_lowlevel = 0 
  
```

```diff
  
              phase = (count_lowlevel * Sim2simCfg.sim_config.dt) / motion_loader.record_time 
-             # print("phase",phase)
-             phase %= 0.99
+             
+             # 修复相位处理逻辑
+             if phase >= 1.0:
+                 if not motion_finished:
+                     motion_finished = True
+                     hold_final_pose = True
+                     print("Motion finished, holding final pose...")
+                 phase = 0.99  # 保持在最后一帧
+             else:
+                 motion_finished = False
+                 hold_final_pose = False
+                 
              # 1000hz -> 50hz        
              if count_lowlevel % Sim2simCfg.sim_config.decimation == 0:
```

```diff
                  projected_gravity = quat_rotate_inverse(_q, _v)
  
-                 phase2pi = 2 * 3.1415926 * phase
+                 # 如果动作结束，使用固定的相位值避免跳跃
+                 if hold_final_pose:
+                     phase_for_obs = 0.99
+                 else:
+                     phase_for_obs = phase
+                     
+                 phase2pi = 2 * 3.1415926 * phase_for_obs
                  obs[0, 0:3] = omega 
                  obs[0, 3:6] = projected_gravity 
```

```diff
  
                  hist_obs = np.concatenate((hist_obs[:, env.num_single_obs:], obs[:, :env.num_single_obs]), axis=-1).astype(np.float32)
-                 action_lab = policy_jit(torch.from_numpy(hist_obs.astype(np.float32))).detach().numpy()
-                 # print(action_lab)
-                 last_action_lab = action_lab
+                 
+                 if not hold_final_pose:
+                     action_lab = policy_jit(torch.from_numpy(hist_obs.astype(np.float32))).detach().numpy()
+                     last_action_lab = action_lab
+                 else:
+                     # 动作结束时，逐渐减小动作幅度
+                     action_lab = last_action_lab * 0.95  # 逐渐衰减到0
+                     last_action_lab = action_lab
+                 
                  action = np.clip(
                      action,
```

```diff
                  for i in range(env.num_actions):
                      target_q_delta_mjc[0][i] = target_q_delta_lab[0][mjc2lab_list[i]] 
+                 
                  dof_pos_ref = motion_loader.get_dof_pos_batch(phase=torch.Tensor([phase]))[0].cpu().numpy()
                  for i in range(env.num_actions):
-                     # import ipdb; ipdb.set_trace();
                      target_q_mujoco[0][i] = dof_pos_ref[i] + target_q_delta_mjc[0][i] 
                  
-                 # print("target_q_mujoco",target_q_mujoco)
- 
+                 # 添加目标位置的平滑过渡
+                 if count_lowlevel > Sim2simCfg.sim_config.decimation:  # 不是第一次
+                     alpha = 0.1  # 平滑系数
+                     target_q_mujoco = alpha * target_q_mujoco + (1 - alpha) * last_target_q_mujoco
+                 
+                 last_target_q_mujoco = target_q_mujoco.copy()
  
              # target_q_mujoco = np.zeros((env.num_actions), dtype=np.double)
              target_dq = np.zeros((env.num_actions), dtype=np.double)
-             # print("target_q_mujoco",target_q_mujoco)
-             # print("Sim2simCfg.robot_config.kds",Sim2simCfg.robot_config.kds,Sim2simCfg.robot_config.kps)
-             # print(target_q_delta_lab.shape)
-             # print(q.shape)
+             
              tau  = pd_control(
                  target_q_mujoco, q, Sim2simCfg.robot_config.kps, target_dq, dq, Sim2simCfg.robot_config.kds
```

```diff
                  tau, -Sim2simCfg.robot_config.tau_limit, Sim2simCfg.robot_config.tau_limit
              )[0]  # Clamp torques
-             # tau = np.clip(
-             #     tau, 0, 0
-             # )[0]
-             # print("tau", tau)
-             # tau = tau * 0.5 + last_tau * 0.5
+             
+             # 添加力矩平滑
+             tau_smooth_alpha = 0.2
+             tau = tau_smooth_alpha * tau + (1 - tau_smooth_alpha) * last_tau
              last_tau = tau
-             # import ipdb; ipdb.set_trace()
-             # if count_lowlevel%5==0:
+             
              data.ctrl = tau
  
```

```diff
              
              end_time = time.time()
-             # print(end_time-step_start)
              
-             # if count_lowlevel % Sim2simCfg.sim_config.decimation == 0:
              viewer.sync()
-             # count_lowlevel+=1
              # Rudimentary time keeping, will drift relative to wall clock.
              time_until_next_step = model.opt.timestep - (time.time() - step_start)
```

---

<think><details><summary>Thought Process</summary>现在我已经修复了主要的问题。让我总结一下所做的改动：

1. **移除了相位跳跃**：原来的`phase %= 0.99`会导致phase突然从0.99跳回0，现在改为当phase >= 1.0时保持在0.99，并设置一个标志来处理动作结束状态。

2. **添加了动作结束时的特殊处理**：
   - 当动作结束时，逐渐减小策略网络的输出幅度
   - 保持phase在最后一帧，避免跳跃

3. **添加了目标位置的平滑过渡**：使用指数平滑来减少目标位置的突变

4. **添加了力矩平滑**：对输出的力矩进行平滑处理，减少控制的剧烈变化

这些修改应该能显著改善动作结束后机器人失控的问题。</details></think>

---

## 修复总结

我已经修复了导致机器人在动作结束后蜷缩乱飞的问题。主要的修改包括：

### 1. **消除相位跳跃**
- **原问题**：`phase %= 0.99` 导致相位从0.99突然跳回0
- **解决方案**：当phase >= 1.0时，保持在0.99并设置标志位，避免突然跳跃

### 2. **动作结束时的平滑处理**
- 检测动作结束状态
- 逐渐衰减策略网络的输出（每次乘以0.95）
- 保持phase在最后一帧，避免参考姿态突变

### 3. **目标位置平滑**
- 添加指数平滑：`target_q_mujoco = α * new_target + (1-α) * last_target`
- 减少目标位置的突然变化

### 4. **力矩平滑**
- 对PD控制器输出的力矩进行平滑处理
- 避免控制力矩的剧烈变化

### 核心原理
原来的问题是：**相位跳跃 → 目标姿态突变 → PD控制器产生巨大力矩 → 机器人失控**

现在的解决方案：**平滑相位过渡 → 渐进姿态变化 → 平滑力矩输出 → 稳定控制**

运行修复后的代码，机器人在动作结束时应该会平滑地保持最后的姿态，而不会出现蜷缩乱飞的现象。

---

